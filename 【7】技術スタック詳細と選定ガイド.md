実装に向けて、具体的な技術選定の判断基準とベストプラクティスを提示します。
# 技術スタック選定ガイド

## 1. バックエンドフレームワーク

### 1-1. 比較表

| 項目 | FastAPI | Django | Node.js (Express/NestJS) | Go (Gin) |
|------|---------|--------|-------------------------|----------|
| **学習曲線** | 低（Python経験者なら容易） | 中（多機能で複雑） | 中（非同期が難）| 高（言語習得必要）|
| **開発速度** | 高（自動ドキュメント生成） | 高（バッテリー同梱） | 中 | 中 |
| **パフォーマンス** | 高（非同期） | 中 | 高（非同期） | 最高 |
| **型安全性** | 高（Pydantic） | 中 | 低（TSなら高） | 最高 |
| **エコシステム** | 成長中 | 最大 | 最大 | 成長中 |
| **LLM統合** | ★★★★★ | ★★★☆☆ | ★★★★☆ | ★★★☆☆ |
| **非同期処理** | ★★★★★ | ★★☆☆☆ | ★★★★★ | ★★★★★ |
| **保守性** | ★★★★☆ | ★★★★★ | ★★★☆☆ | ★★★★☆ |

### 1-2. 推奨：FastAPI

**選定理由：**
```yaml
長所:
  - Python製でデータサイエンス・LLMライブラリとの親和性が高い
  - 非同期処理がネイティブサポート（await/async）
  - 自動OpenAPI/Swaggerドキュメント生成
  - Pydanticによる型安全な開発
  - 高速（Node.js, Go並み）
  - 学習コストが低い

短所:
  - 比較的新しい（2018年〜）
  - Django程のバッテリー同梱はない
  
最適な用途:
  ✓ LLM統合が中心のシステム
  ✓ 非同期処理が多い
  ✓ APIファーストの設計
```

**実装例：**
```python
# main.py
from fastapi import FastAPI, Depends, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from typing import List, Optional
import asyncio

app = FastAPI(
    title="Fund IC Automation API",
    version="1.0.0",
    docs_url="/api/docs"
)

# CORS設定
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://app.yourfund.com"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 依存性注入
async def get_db():
    db = await get_database_connection()
    try:
        yield db
    finally:
        await db.close()

async def get_current_user(token: str = Depends(oauth2_scheme)):
    user = await verify_token(token)
    if not user:
        raise HTTPException(401, "Invalid token")
    return user

# エンドポイント例
@app.post("/api/v1/cases", response_model=CaseResponse)
async def create_case(
    case: CaseCreate,
    background_tasks: BackgroundTasks,
    db = Depends(get_db),
    current_user = Depends(get_current_user)
):
    # 案件作成
    new_case = await db.cases.create({
        **case.dict(),
        "lead_partner_id": current_user.id,
        "status": "draft"
    })
    
    # バックグラウンドでPUB収集を開始
    background_tasks.add_task(
        start_pub_collection_workflow,
        new_case.id
    )
    
    return new_case

@app.get("/api/v1/cases/{case_id}/observations")
async def get_observations(
    case_id: str,
    section: Optional[str] = None,
    source_tag: Optional[str] = None,
    db = Depends(get_db)
):
    query = db.observations.find({"case_id": case_id})
    
    if section:
        query = query.filter({"section": section})
    if source_tag:
        query = query.filter({"source_tag": source_tag})
    
    observations = await query.to_list()
    return observations

# WebSocketエンドポイント
@app.websocket("/ws/cases/{case_id}")
async def websocket_endpoint(websocket: WebSocket, case_id: str):
    await websocket.accept()
    await subscribe_to_case_updates(case_id, websocket)
```

---

## 2. データベース

### 2-1. 比較表

| 項目 | PostgreSQL | MongoDB | MySQL | DynamoDB |
|------|-----------|---------|-------|----------|
| **データモデル** | リレーショナル | ドキュメント | リレーショナル | キーバリュー |
| **JSON対応** | ★★★★★（JSONB） | ★★★★★ | ★★★☆☆ | ★★★★☆ |
| **トランザクション** | ★★★★★ | ★★★★☆ | ★★★★★ | ★★☆☆☆ |
| **全文検索** | ★★★★☆（GIN） | ★★★☆☆ | ★★★☆☆ | ☆☆☆☆☆ |
| **スケーラビリティ** | ★★★★☆ | ★★★★★ | ★★★☆☆ | ★★★★★ |
| **運用コスト** | 低（セルフホスト可） | 低〜中 | 低 | 高（AWS依存）|
| **学習曲線** | 低（標準SQL） | 中 | 低 | 中 |

### 2-2. 推奨：PostgreSQL + Redis

**PostgreSQL（メインDB）**
```yaml
選定理由:
  ✓ リレーショナルモデルが投資データに適合
  ✓ JSONB型で柔軟なスキーマも可能
  ✓ 強力なトランザクション保証
  ✓ GIN/GiSTインデックスで高速検索
  ✓ セキュリティと成熟度が高い
  ✓ コスト効率が良い

最適な用途:
  - cases, observations, documents等の構造化データ
  - トランザクション整合性が重要なデータ
  - 複雑なクエリが必要な分析
```

**Redis（キャッシュ・セッション）**
```yaml
選定理由:
  ✓ 超高速（メモリ内DB）
  ✓ セッション管理に最適
  ✓ LLM応答のキャッシング
  ✓ レート制限の実装が容易

最適な用途:
  - API応答のキャッシング
  - セッション・JWT管理
  - リアルタイム処理のキュー
```

**設定例：**
```python
# database.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
import redis.asyncio as redis

# PostgreSQL
DATABASE_URL = "postgresql+asyncpg://user:pass@localhost/funddb"

engine = create_async_engine(
    DATABASE_URL,
    echo=True,
    pool_size=20,
    max_overflow=0,
    pool_pre_ping=True,  # 接続確認
)

async_session_maker = sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)

# Redis
redis_client = redis.Redis(
    host='localhost',
    port=6379,
    decode_responses=True,
    max_connections=50
)

# キャッシュデコレータ
def cache(ttl: int = 3600):
    def decorator(func):
        async def wrapper(*args, **kwargs):
            cache_key = f"{func.__name__}:{hash_args(args, kwargs)}"
            
            # キャッシュ確認
            cached = await redis_client.get(cache_key)
            if cached:
                return json.loads(cached)
            
            # 実行
            result = await func(*args, **kwargs)
            
            # キャッシュに保存
            await redis_client.setex(
                cache_key,
                ttl,
                json.dumps(result)
            )
            
            return result
        return wrapper
    return decorator
```

---

## 3. フロントエンド

### 3-1. 比較表

| 項目 | React | Vue.js | Svelte | Next.js (React) |
|------|-------|--------|--------|-----------------|
| **学習曲線** | 中 | 低 | 低 | 中〜高 |
| **パフォーマンス** | 高 | 高 | 最高 | 高 |
| **エコシステム** | 最大 | 大 | 成長中 | 大 |
| **TypeScript対応** | ★★★★★ | ★★★★☆ | ★★★★★ | ★★★★★ |
| **SSR** | 要Next.js | ★★★★☆（Nuxt） | ★★★★☆（SvelteKit） | ★★★★★ |
| **コンポーネント** | 最多 | 多 | 少 | 最多 |

### 3-2. 推奨：React + TypeScript + Tailwind CSS

**選定理由：**
```yaml
React:
  ✓ 最大のエコシステム
  ✓ 豊富なコンポーネントライブラリ
  ✓ 企業採用実績が多い
  ✓ エンジニア採用が容易

TypeScript:
  ✓ 型安全性による品質向上
  ✓ IDEサポートが強力
  ✓ リファクタリングが安全

Tailwind CSS:
  ✓ 高速なUI開発
  ✓ 一貫したデザイン
  ✓ カスタマイズ性が高い
```

**技術スタック詳細：**
```javascript
// package.json
{
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "typescript": "^5.0.0",
    
    // ルーティング
    "react-router-dom": "^6.15.0",
    
    // 状態管理
    "zustand": "^4.4.0",  // シンプルで軽量
    // または
    "jotai": "^2.4.0",    // Atomicな状態管理
    
    // データフェッチ
    "@tanstack/react-query": "^4.35.0",
    
    // フォーム
    "react-hook-form": "^7.45.0",
    "zod": "^3.22.0",  // バリデーション
    
    // UI コンポーネント
    "shadcn/ui": "latest",  // headless UI
    "@radix-ui/react-*": "^1.0.0",
    
    // スタイリング
    "tailwindcss": "^3.3.0",
    
    // WebSocket
    "socket.io-client": "^4.6.0",
    
    // 日付処理
    "date-fns": "^2.30.0",
    
    // チャート
    "recharts": "^2.8.0"
  }
}
```

**実装例：**
```typescript
// CaseDetailPage.tsx
import React, { useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import { useWebSocket } from '@/hooks/useWebSocket';

interface Observation {
  id: string;
  field: string;
  value: string;
  source_tag: string;
  confidence: number;
}

export function CaseDetailPage() {
  const { caseId } = useParams<{ caseId: string }>();
  
  // データフェッチ
  const { data: caseData, isLoading } = useQuery({
    queryKey: ['case', caseId],
    queryFn: () => fetch(`/api/v1/cases/${caseId}`).then(r => r.json()),
  });
  
  const { data: observations } = useQuery({
    queryKey: ['observations', caseId],
    queryFn: () => fetch(`/api/v1/cases/${caseId}/observations`).then(r => r.json()),
  });
  
  // WebSocketでリアルタイム更新
  useWebSocket(`/ws/cases/${caseId}`, {
    onMessage: (message) => {
      if (message.type === 'observation_updated') {
        // React Queryのキャッシュを更新
        queryClient.invalidateQueries(['observations', caseId]);
      }
    }
  });
  
  if (isLoading) {
    return <LoadingSpinner />;
  }
  
  return (
    <div className="container mx-auto p-6">
      <header className="mb-6">
        <h1 className="text-3xl font-bold">{caseData.company_name}</h1>
        <p className="text-gray-600">Stage: {caseData.stage}</p>
      </header>
      
      <Tabs defaultValue="info">
        <TabsList>
          <TabsTrigger value="info">情報収集</TabsTrigger>
          <TabsTrigger value="analysis">分析</TabsTrigger>
          <TabsTrigger value="report">レポート</TabsTrigger>
        </TabsList>
        
        <TabsContent value="info">
          <ObservationsTable 
            observations={observations} 
            caseId={caseId}
          />
        </TabsContent>
        
        <TabsContent value="analysis">
          <AnalysisView caseId={caseId} />
        </TabsContent>
        
        <TabsContent value="report">
          <ReportView caseId={caseId} />
        </TabsContent>
      </Tabs>
    </div>
  );
}
```

---

## 4. ワークフローオーケストレーション

### 4-1. 比較表

| 項目 | Temporal | Airflow | Celery | Prefect |
|------|----------|---------|--------|---------|
| **複雑なワークフロー** | ★★★★★ | ★★★★☆ | ★★☆☆☆ | ★★★★☆ |
| **状態管理** | ★★★★★ | ★★★☆☆ | ★★☆☆☆ | ★★★★☆ |
| **エラーハンドリング** | ★★★★★ | ★★★☆☆ | ★★★☆☆ | ★★★★☆ |
| **人間の介入** | ★★★★★（シグナル） | ★★☆☆☆ | ★☆☆☆☆ | ★★★☆☆ |
| **学習曲線** | 中〜高 | 中 | 低 | 低 |
| **運用コスト** | 中 | 高 | 低 | 低〜中 |

### 4-2. 推奨：Temporal

**選定理由：**
```yaml
長所:
  ✓ 複雑な長期実行ワークフローに最適
  ✓ 人間の承認待ちなどを自然に表現（Signal/Query）
  ✓ 強力なエラーハンドリング・リトライ
  ✓ 状態が自動的に永続化
  ✓ ワークフローのバージョニング
  ✓ 可視化ツールが充実

短所:
  - 学習コストがやや高い
  - 追加のインフラが必要（Temporalサーバー）

最適な用途:
  ✓ 長期実行プロセス（数日〜数週間）
  ✓ 人間の介入が必要なワークフロー
  ✓ 複雑な条件分岐・並列処理
```

**実装例：**
```python
# workflow.py
from temporalio import workflow, activity
from datetime import timedelta

@workflow.defn
class ICMaterialWorkflow:
    def __init__(self):
        self.conf_ready = False
    
    @workflow.run
    async def run(self, case_id: str) -> dict:
        # Phase 1: PUB収集
        pub_result = await workflow.execute_activity(
            collect_pub_info,
            case_id,
            start_to_close_timeout=timedelta(minutes=10),
            retry_policy={"max_attempts": 3}
        )
        
        # Phase 2: EXT収集（並列）
        ext_results = await asyncio.gather(
            workflow.execute_activity(call_crunchbase, case_id),
            workflow.execute_activity(call_similarweb, case_id)
        )
        
        # Phase 3: 正規化
        normalized = await workflow.execute_activity(
            normalize_observations,
            {"pub": pub_result, "ext": ext_results},
            start_to_close_timeout=timedelta(minutes=5)
        )
        
        # Phase 4: CONF処理（人間の承認を待つ）
        # シグナルを待機
        await workflow.wait_condition(
            lambda: self.conf_ready,
            timeout=timedelta(days=7)  # 最大1週間待つ
        )
        
        conf_result = await workflow.execute_activity(
            process_conf_documents,
            case_id,
            start_to_close_timeout=timedelta(minutes=15)
        )
        
        # Phase 5: レポート生成
        report = await workflow.execute_activity(
            generate_report,
            case_id,
            start_to_close_timeout=timedelta(minutes=5)
        )
        
        return {"status": "completed", "report_id": report["id"]}
    
    @workflow.signal
    def conf_documents_ready(self):
        """人間が文書をアップロード完了したことをシグナル"""
        self.conf_ready = True
    
    @workflow.query
    def get_status(self) -> dict:
        """現在のワークフロー状態を問い合わせ"""
        return {
            "conf_ready": self.conf_ready,
            "current_stage": "waiting_for_conf" if not self.conf_ready else "processing"
        }

# アクティビティの定義
@activity.defn
async def collect_pub_info(case_id: str) -> dict:
    """PUB情報収集"""
    # 実装
    pass

# ワークフローの実行
async def start_workflow(case_id: str):
    from temporalio.client import Client
    
    client = await Client.connect("localhost:7233")
    
    handle = await client.start_workflow(
        ICMaterialWorkflow.run,
        case_id,
        id=f"ic-workflow-{case_id}",
        task_queue="fund-automation"
    )
    
    return handle

# 人間がCONF文書をアップロードしたときに呼ばれる
async def notify_conf_ready(case_id: str):
    from temporalio.client import Client
    
    client = await Client.connect("localhost:7233")
    
    handle = client.get_workflow_handle(f"ic-workflow-{case_id}")
    await handle.signal(ICMaterialWorkflow.conf_documents_ready)
```

---

## 5. クラウドプロバイダー

### 5-1. 比較表

| 項目 | AWS | Google Cloud | Azure |
|------|-----|--------------|-------|
| **総合力** | ★★★★★ | ★★★★☆ | ★★★★☆ |
| **AIサービス** | ★★★★☆ | ★★★★★（Vertex AI） | ★★★★☆ |
| **PostgreSQL** | ★★★★☆（RDS） | ★★★★★（Cloud SQL） | ★★★★☆ |
| **価格** | 中〜高 | 低〜中 | 中 |
| **日本リージョン** | ✓ Tokyo | ✓ Tokyo/Osaka | ✓ Tokyo |
| **ドキュメント** | 最充実 | 充実 | 充実 |

### 5-2. 推奨：Google Cloud Platform（GCP）

**選定理由：**
```yaml
長所:
  ✓ Vertex AIでLLM統合が容易（Gemini直接利用）
  ✓ Cloud Runでコンテナを簡単デプロイ
  ✓ BigQueryで大規模分析
  ✓ 価格が比較的安価
  ✓ GCPのネットワークが高速
  ✓ Google Workspaceとの連携が容易

短所:
  - AWSほど多機能ではない
  - 一部サービスの成熟度がAWSに劣る

推奨サービス:
  - Cloud Run: FastAPIアプリのホスティング
  - Cloud SQL: PostgreSQL
  - Cloud Storage: ファイル保管
  - Vertex AI: Gemini API
  - Cloud Tasks: バックグラウンドジョブ
  - Cloud Logging/Monitoring: 監視
```

**アーキテクチャ例（GCP）:**
```
┌─────────────────────────────────────────┐
│ Cloud Load Balancing                    │
│ (HTTPS, SSL証明書自動更新)              │
└───────────┬─────────────────────────────┘
            │
┌───────────▼─────────────────────────────┐
│ Cloud Run (FastAPI)                     │
│ - オートスケール                        │
│ - Pay-per-use                           │
│ - コンテナベース                        │
└───────────┬─────────────────────────────┘
            │
┌───────────▼─────────────────────────────┐
│ Cloud SQL (PostgreSQL)                  │
│ - 自動バックアップ                      │
│ - 高可用性構成                          │
└─────────────────────────────────────────┘
            │
┌───────────▼─────────────────────────────┐
│ Cloud Storage                           │
│ - 文書ファイル保管                      │
│ - バージョニング有効                    │
└─────────────────────────────────────────┘
```

---

## 6. モニタリング・ログ

### 6-1. 推奨：Datadog または GCP Cloud Monitoring

**Datadog（推奨：本格運用）**
```yaml
長所:
  ✓ 統合監視（メトリクス、ログ、APM）
  ✓ 強力なダッシュボード
  ✓ アラート設定が柔軟
  ✓ 複数クラウド対応

価格: $15-30/host/month

適用シーン:
  - 本番環境の詳細監視
  - 複雑なアラートルール
  - チーム規模が大きい
```

**GCP Cloud Monitoring（推奨：低コスト）**
```yaml
長所:
  ✓ GCPとの統合が完璧
  ✓ 追加コストが低い
  ✓ シンプルで十分な機能

価格: 低（無料枠が大きい）

適用シーン:
  - 小規模チーム
  - コスト重視
  - GCP環境のみ
```

---

## 7. CI/CD

### 7-1. 推奨：GitHub Actions + Cloud Build

**GitHub Actions**
```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov
      
      - name: Run tests
        run: pytest --cov=app tests/
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
  
  deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}
      
      - name: Build and push Docker image
        run: |
          gcloud builds submit --tag gcr.io/PROJECT_ID/fund-automation:${{ github.sha }}
      
      - name: Deploy to Cloud Run
        run: |
          gcloud run deploy fund-automation \
            --image gcr.io/PROJECT_ID/fund-automation:${{ github.sha }} \
            --platform managed \
            --region asia-northeast1 \
            --allow-unauthenticated
```

---

## 8. 推奨技術スタック（総まとめ）

```yaml
【最小構成（MVP）】
バックエンド: FastAPI + Python 3.11
データベース: PostgreSQL 15 + Redis
フロントエンド: React + TypeScript + Vite
ワークフロー: Celery（シンプル）
クラウド: GCP Cloud Run
監視: GCP Cloud Monitoring
CI/CD: GitHub Actions

推定コスト: ¥150,000-¥250,000/月

【本番構成（フルスペック）】
バックエンド: FastAPI + Python 3.11
データベース: PostgreSQL 15 (Cloud SQL) + Redis (Memorystore)
フロントエンド: React + TypeScript + Vite + Tailwind
ワークフロー: Temporal
クラウド: GCP (Cloud Run, Cloud SQL, Cloud Storage, Vertex AI)
監視: Datadog
CI/CD: GitHub Actions + Cloud Build
検索: Elasticsearch（オプション）

推定コスト: ¥300,000-¥500,000/月
```

---

このガイドに基づいて技術選定を行うことで、実装リスクを最小化し、保守性の高いシステムを構築できます。

